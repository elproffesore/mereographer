<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MereoGrapher</title>
    <style>
      @font-face {
        font-family: "Atkinson";
        src: url("include/fonts/Atkinson-Hyperlegible-Regular-102a.woff2")
          format("woff2-variations");
        font-style: normal;
        font-weight: normal;
      }

      @font-face {
        font-family: "Atkinson";
        src: url("include/fonts/Atkinson-Hyperlegible-Italic-102a.woff2")
          format("woff2-variations");
        font-style: italic;
        font-weight: normal;
      }

      @font-face {
        font-family: "Atkinson";
        src: url("include/fonts/Atkinson-Hyperlegible-Bold-102a.woff2")
          format("woff2-variations");
        font-style: normal;
        font-weight: bold;
      }

      @font-face {
        font-family: "Atkinson";
        src: url("include/fonts/Atkinson-Hyperlegible-BoldItalic-102a.woff2")
          format("woff2-variations");
        font-style: italic;
        font-weight: bold;
      }

      body {
        font-family: Atkinson, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        font-size: 14pt;
        line-height: 1.3;
      }

      .extracted {
        background-color: #b2ff2d;
        cursor: pointer;
      }

      #app {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        margin: 16px;
      }

      #text-container {
        width: 500px;
        z-index: 20;
      }

      #annotation-wrapper {
        position: relative;
        z-index: 10;
      }

      .annotation {
        position: absolute;
        max-width: 300px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        cursor: grab;
      }
      #annotation-wrapper {
        position: relative;
        z-index: 10;
      }
      #annotation-container {
        height: 100vh;
        width: 100%;
        position: fixed;
        top: 0;
        left: 0;
      }

      #comment-container {
        z-index: 30;
      }
      #connections-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
    </style>
  </head>

  <body>
    <script src="include/libs/marked.min.js"></script>
    <script src="include/libs/rangy.min.js"></script>
    <script src="include/libs/d3.min.js"></script>
    <div id="app">
      <canvas id="connections-canvas"></canvas>
      <div id="text-container"></div>
      <div id="annotation-wrapper"> 
              <div id="annotation-container"></div>

      </div>
      <div id="comment-container"></div>
    </div>
    <script>
      //
      // GLOBAL VARIABLES
      //
      let canvas = null;
      let ctx = null;
      let annotations = [];
      let drawings = [];
      let annotationsMovement = false;
      //
      // HELPER FUNCTIONS
      //
      // Recursive function to get the parent element with a hashed ID
      function getParentWithLongId(node) {
        if (!node || !node.parentElement) return null;
        if (node.parentElement.id && node.parentElement.id.length == 12) {
          return node.parentElement;
        }
        return getParentWithLongId(node.parentElement);
      }
      // Function to hash text using SHA-1 and crop it to generate a unique content dependent ID
      async function hashText(text) {
        const hashBuffer = await self.crypto.subtle.digest(
          "SHA-1",
          new TextEncoder().encode(text)
        );
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("")
          .slice(0, 10);
        return hashHex;
      }
        function resetPage(){
        // Remove all annotations
        annotations = [];
        document.querySelectorAll(".annotation").forEach((el) => {
          el.remove();
        });
        document.querySelectorAll(".extracted").forEach((el) => {
          el.outerHTML = el.textContent;
        });
      }
      //
      // LOADING TEXT
      //
      (async function () {
        // Get text from server and parse it via marked.js
        const response = await fetch(
          `${location.pathname}media/texts/latour-a-cautious-promotheus.md`
        );
        const text = await response.text();
        const textContainer = document.getElementById("text-container");
        textContainer.innerHTML = marked.parse(text);

        // Give each section a unique ID that is based on its hashed contents
        let promises = Array.from(
          document.querySelector("#text-container").childNodes
        ).map(async (child) => {
          child.id = "id" + (await hashText(child.textContent));
        });
        // Wait for all promises to resolve before loading URL encoded annotations
        Promise.all(promises).then(() => {
          getHashedAnnotations();
            setupCanvas();
            updateCanvas();
        });
      })();
      //
      // HANDLING HASHED URL
      //

      window.addEventListener("hashchange", (e) => {
        // Check if the hash has changed and if we are not in edit mode
        getHashedAnnotations();
      });
      function setHashedAnnotations() {
        // Update the URL hash with the new annotation
        let hash = annotations
          .map((a) => {
            return `[${a.mode}][${a.id}][${a.absoluteStartOffset}-${a.absoluteEndOffset}][${a.annotationX}-${a.annotationY}]`;
          })
          .join(",");

        history.pushState(
          null,
          null,
          location.pathname + location.search + "#" + hash
        );
      }
      // Handle URL encoded annotations
      function getHashedAnnotations() {
        resetPage();
        // Get the hash from the URL and split it into an array
        let instructions = location.hash
          .split(",")
          .filter((action) => action.length > 0);
        if (instructions.length == 0) return;
        // Iterate over the instructions and decode them
        let ranges = instructions
          .map((action) => action.replace("#", "").replaceAll("%20", " "))
          .map((action) => {
            // [H][id][startOffset-endOffset][annotationX-annotationY]
            let matches = [...action.matchAll(/\[(.*?)\]/g)];
            if (matches.length != 4) return null;
            let [mode, parentContainerID, textRange, annotationPosition] =
              matches.map((match) => match[1]);
            // Create start and end offsets and nthChild
            let [absoluteStartOffset, absoluteEndOffset] = textRange.split("-");
            let [annotationX, annotationY] = annotationPosition.split("-");
            let element = document.querySelector("#" + parentContainerID);
            if (element) {
              // Create a range and set the start and end points
              let rangeElement = document.createRange();
              let nthChildStart = 0;
              let paddingStart = 0;
              let nthChildEnd = 0;
              let paddingEnd = 0;
              element.childNodes = Array.from(element.childNodes).filter(childNode => childNode.textContent.length > 0);
                // Find the nth child for the start and end offsets
                if(element.childNodes.length > 1) {      
                    while (
                        nthChildStart < element.childNodes.length &&
                        paddingStart + element.childNodes[nthChildStart].textContent.length < absoluteStartOffset 
                        ) {
                        paddingStart += element.childNodes[nthChildStart].textContent
                            .length;
                        nthChildStart++;
                        }
                    while (
                        nthChildEnd < element.childNodes.length &&
                        paddingEnd + element.childNodes[nthChildEnd].textContent.length < absoluteEndOffset
                        ) {
                        paddingEnd += element.childNodes[nthChildEnd].textContent
                            .length;
                        nthChildEnd++;
                        }
                }
                // Set the start and end points of the range
                let startOffset =  absoluteStartOffset - paddingStart ;
                let endOffset = absoluteEndOffset - paddingEnd;
              // Set the start and end points of the range  
                rangeElement.setStart(
                    element.childNodes[nthChildStart],
                    startOffset
                );
                rangeElement.setEnd(
                    element.childNodes[nthChildEnd],
                    endOffset
                );
              // Create a new annotation object
              createAnnotation(
                mode,
                parentContainerID,
                absoluteStartOffset,
                absoluteEndOffset,
                rangeElement,
                annotationX,
                annotationY
              );
            }
          });
      }
      //
      // HANDLING ANNOTATIONS
      //
      function createAnnotation(
        mode,
        id,
        absoluteStartOffset,
        absoluteEndOffset,
        range,
        annotationX = null,
        annotationY = null
      ) {
        // Create a span element and wrap the selected text with it
        let spanWrapper = document.createElement("span");
        spanWrapper.id = "id"+self.crypto.randomUUID();
        spanWrapper.classList.add("extracted");
        range.surroundContents(spanWrapper);
        // Clone the span element and append it to the annotation container
        let clone = spanWrapper.cloneNode(true);
        clone.id = spanWrapper.id + "-annotation";
        clone.classList.add("annotation");
        clone.classList.remove("extracted"); 
        document.querySelector("#annotation-container").appendChild(clone);
        // Set the position of the annotation
        let boundingClient = clone.getBoundingClientRect();
        clone.style.left = annotationX ? annotationX + "px" : boundingClient.left + "px";  
        clone.style.top = annotationY ? annotationY + "px" : boundingClient.top + "px";
        clone.addEventListener("mousedown",(e) => {
            e.preventDefault();
            annotationsMovement = true;
            annotationsMovementID = clone.id
        })

        // Create a new annotation object
        let annotation = {
          mode,
          id,
          absoluteStartOffset,
          absoluteEndOffset,
          text: range.toString(),
          spanID: spanWrapper.id,
          annotationID: clone.id,
          annotationX: annotationX ? annotationX : boundingClient.left,
          annotationY: annotationY ? annotationY : boundingClient.top
        };
        annotations.push(annotation);
        setHashedAnnotations();
      }
      function deleteAnnotation() {}
      function editAnnotation() {}
      window.addEventListener("mousemove", (e) => {
        if (annotationsMovement) {
          let annotation = document.querySelector("#" + annotationsMovementID);
          annotation.style.left = e.clientX + "px";
          annotation.style.top = e.clientY + "px";
          annotations.forEach((a) => {
            if (a.annotationID == annotationsMovementID) {
              a.annotationX = e.clientX;
              a.annotationY = e.clientY;
              //setHashedAnnotations(); -> to computation intensive
            }
          });
        }
      });
      window.addEventListener("mouseup", (e) => {
        if (annotationsMovement) {
          annotationsMovement = false;
          annotationsMovementID = null;
          setHashedAnnotations();
        }
      });
      function moveAnnotation() {

      }
      //Handle highlighting and creation of extracted elements
      window.addEventListener("mouseup", (e) => {
        e.preventDefault();
        try {
          let selection = window.getSelection();
          let range = selection.getRangeAt(0);
          // Check if the selection is empty or if the selected text is too short
          if (
            range == undefined ||
            range.collapsed ||
            range.toString().length < 2 ||
            range.toString().length > 200
          ) {
            return;
          }
          // We need to encode where the selection has started and where it ended
          let nthChildStart = 0;
          let paddingStart = 0;
          let parent = selection.anchorNode.parentElement;
          while (parent.childNodes[nthChildStart] != selection.anchorNode) {
            paddingStart += parent.childNodes[nthChildStart].textContent.length;
            nthChildStart++;
          }

          let nthChildEnd = nthChildStart;
          let paddingEnd = paddingStart;
          while (parent.childNodes[nthChildEnd] != selection.focusNode) {
            paddingEnd += parent.childNodes[nthChildEnd].textContent.length;
            nthChildEnd++;
          }

          // Get the parent element with a long ID
          let parentID = getParentWithLongId(selection.anchorNode).id;
          let startOffset = selection.anchorOffset;
          let endOffset = selection.focusOffset;
          let absoluteStartOffset = startOffset + paddingStart;
          let absoluteEndOffset = endOffset + paddingEnd;

          // Create a new annotation object
          createAnnotation(
            "H",
            parentID,
            absoluteStartOffset,
            absoluteEndOffset,
            range
          );
          // Remove all ranges from the selection
          selection.removeAllRanges();
        } catch (e) {
          console.log(e);
        }
      });
      //
      // Handling Connections between Annotations
      //
      function setupCanvas(){
            canvas = document.querySelector("#connections-canvas");
            canvas.width = window.innerWidth*2; // Adjust for high DPI screens
            canvas.height = window.innerHeight*2;
            canvas.style.width = `${window.innerWidth}px`;
            canvas.style.height = `${window.innerHeight}px`;
            ctx = canvas.getContext("2d");
            ctx.scale(2, 2); // Adjust for high DPI screens
            ctx.lineWidth =  1;
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#11111155';
      }
        function updateCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Set the canvas size to match the window size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Draw connections between annotations
            annotations.map(annotation => {
                if (annotation.mode != "H") return;
                let annotationElement = document.querySelector("#" + annotation.annotationID);
                let annotationBoundingClient = annotationElement.getBoundingClientRect();
                let spanElement = document.querySelector("#" + annotation.spanID);
                let spanBoundingClient = spanElement.getBoundingClientRect();
                let controlPoint1 = {
                    x: annotationBoundingClient.left,
                    y: annotationBoundingClient.top + annotationBoundingClient.height / 2
                };
                let controlPoint2 = {
                    x: annotationBoundingClient.left -150,
                    y: annotationBoundingClient.top + annotationBoundingClient.height / 2
                };
                let controlPoint3 = {
                    x: spanBoundingClient.left + spanBoundingClient.width + 150,
                    y: spanBoundingClient.top + spanBoundingClient.height / 2
                };
                let controlPoint4 = {
                    x: spanBoundingClient.left + spanBoundingClient.width,
                    y: spanBoundingClient.top + spanBoundingClient.height / 2
                };
                ctx.beginPath();
                ctx.moveTo(controlPoint1.x, controlPoint1.y);
                ctx.bezierCurveTo(
                    controlPoint2.x,
                    controlPoint2.y,
                    controlPoint3.x,
                    controlPoint3.y,
                    controlPoint4.x,
                    controlPoint4.y
                );
                ctx.stroke();

            })
        requestAnimationFrame(updateCanvas);
    }

    </script>
  </body>
</html>
